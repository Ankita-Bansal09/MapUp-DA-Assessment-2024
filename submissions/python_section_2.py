# -*- coding: utf-8 -*-
"""Python_Section_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q2hXv5yMqV8clivnp5lDrzpEkqNhyVSZ

# PYTHON SECTION 2

Q9. **Distance Matrix Calculation**

Problem Statement

Create a function named calculate_distance_matrix that takes the dataset-2.csv as input and generates a DataFrame representing distances between IDs.

The resulting DataFrame should have cumulative distances along known routes, with diagonal values set to 0. If distances between toll locations A to B and B to C are known, then the distance from A to C should be the sum of these distances. Ensure the matrix is symmetric, accounting for bidirectional distances between toll locations (i.e. A to B is equal to B to A).
"""

import warnings
warnings.filterwarnings('ignore') # Use warnings.filterwarnings to control warning messages

import pandas as pd

mapup = pd.read_csv('/content/dataset-2.csv')
mapup.head()

def calculate_distance_matrix(df) -> pd.DataFrame:
    """
    Calculate a distance matrix based on the dataframe, df.

    Args:
        df (pandas.DataFrame)

    Returns:
        pandas.DataFrame: Distance matrix
    """
    # Extract unique IDs from the dataset
    unique_ids = pd.unique(df[['id_start', 'id_end']].values.ravel())

    # Initialize the distance matrix with zeros
    distance_matrix = pd.DataFrame(0, index=unique_ids, columns=unique_ids)

    # Populate the distance matrix with given distances
    for _, row in df.iterrows():
        start, end, dist = row['id_start'], row['id_end'], row['distance']
        distance_matrix.loc[start, end] = dist
        distance_matrix.loc[end, start] = dist  # Ensure symmetry

    # Use the Floyd-Warshall algorithm to compute cumulative distances
    for k in unique_ids:
        for i in unique_ids:
            for j in unique_ids:
                if distance_matrix.loc[i, j] == 0 and i != j:
                    # Update distance if going through k provides a shorter path
                    distance_matrix.loc[i, j] = distance_matrix.loc[i, k] + distance_matrix.loc[k, j]
                else:
                    # Keep the current distance if already set or shorter
                    distance_matrix.loc[i, j] = min(distance_matrix.loc[i, j],
                                                    distance_matrix.loc[i, k] + distance_matrix.loc[k, j])

    return distance_matrix

# Calculate the distance matrix using the provided dataset
distance_matrix = calculate_distance_matrix(mapup)
distance_matrix.head()

"""Q10. **Unroll Distance Matrix**

Problem Statement

Create a function unroll_distance_matrix that takes the DataFrame created in Question 9. The resulting DataFrame should have three columns: columns id_start, id_end, and distance.

All the combinations except for same id_start to id_end must be present in the rows with their distance values from the input DataFrame.
"""

def unroll_distance_matrix(df) -> pd.DataFrame:
    """
    Unroll a distance matrix to a DataFrame in the style of the initial dataset.

    Args:
        df (pandas.DataFrame)

    Returns:
        pandas.DataFrame: Unrolled DataFrame containing columns 'id_start', 'id_end', and 'distance'.
    """
    # Initialize an empty list to store the rows of the unrolled DataFrame
    unrolled_data = []

    # Iterate over the distance matrix to extract id_start, id_end, and distance
    for id_start in df.index:
        for id_end in df.columns:
            if id_start != id_end:  # Exclude same id_start and id_end pairs
                # Append the row data as a dictionary
                unrolled_data.append({
                    'id_start': id_start,
                    'id_end': id_end,
                    'distance': df.loc[id_start, id_end]
                })

    # Convert the list of dictionaries to a DataFrame
    unrolled_df = pd.DataFrame(unrolled_data)

    return unrolled_df

unroll_distance_matrix(distance_matrix)

"""Q11. **Finding IDs within Percentage Threshold**

Create a function find_ids_within_ten_percentage_threshold that takes the DataFrame created in Question 10 and a reference value from the id_start column as an integer.

Calculate average distance for the reference value given as an input and return a sorted list of values from id_start column which lie within 10% (including ceiling and floor) of the reference value's average.
"""

def find_ids_within_ten_percentage_threshold(df, reference_id) -> pd.DataFrame:
    """
    Find all IDs whose average distance lies within 10% of the average distance of the reference ID.

    Args:
        df (pandas.DataFrame)
        reference_id (int)

    Returns:
        pandas.DataFrame: DataFrame with IDs whose average distance is within the specified percentage threshold
                          of the reference ID's average distance.
    """
    # Calculate the average distance for each id_start
    average_distances = df.groupby('id_start')['distance'].mean()

    # Get the average distance for the reference ID
    reference_avg_distance = average_distances.get(reference_id, None)

    if reference_avg_distance is None:
        # If reference_id is not in the DataFrame, return an empty DataFrame
        return pd.DataFrame(columns=['id_start'])

    # Calculate the 10% threshold range
    lower_bound = reference_avg_distance * 0.9
    upper_bound = reference_avg_distance * 1.1

    # Find ids whose average distance lies within the 10% threshold
    ids_within_threshold = average_distances[
        (average_distances >= lower_bound) & (average_distances <= upper_bound)
    ].index.tolist()

    # Sort the list of IDs
    ids_within_threshold.sort()

    # Return as a DataFrame
    return pd.DataFrame({'id_start': ids_within_threshold})

find_ids_within_ten_percentage_threshold(mapup,1 )

"""Q12. **Calculate Toll Rate**

Create a function calculate_toll_rate that takes the DataFrame created in Question 10 as input and calculates toll rates based on vehicle types.

The resulting DataFrame should add 5 columns to the input DataFrame: moto, car, rv, bus, and truck with their respective rate coefficients. The toll rates should be calculated by multiplying the distance with the given rate coefficients for each vehicle type:

1. 0.8 for moto
2. 1.2 for car
3. 1.5 for rv
4. 2.2 for bus
5. 3.6 for truck
"""

def calculate_toll_rate(df) -> pd.DataFrame:
    """
    Calculate toll rates for each vehicle type based on the unrolled DataFrame.

    Args:
        df (pandas.DataFrame)

    Returns:
        pandas.DataFrame: DataFrame with additional columns for toll rates for each vehicle type.
    """
    # Define rate coefficients for each vehicle type
    rate_coefficients = {
        'moto': 0.8,
        'car': 1.2,
        'rv': 1.5,
        'bus': 2.2,
        'truck': 3.6
    }

    # Calculate toll rates for each vehicle type and add as new columns
    df['moto'] = df['distance'] * rate_coefficients['moto']
    df['car'] = df['distance'] * rate_coefficients['car']
    df['rv'] = df['distance'] * rate_coefficients['rv']
    df['bus'] = df['distance'] * rate_coefficients['bus']
    df['truck'] = df['distance'] * rate_coefficients['truck']

    return df

mapup2 = calculate_toll_rate(mapup)
mapup2

"""Q13. **Calculate Time-Based Toll Rates**

Create a function named calculate_time_based_toll_rates that takes the DataFrame created in Question 12 as input and calculates toll rates for different time intervals within a day.

The resulting DataFrame should have these five columns added to the input: start_day, start_time, end_day, and end_time.

start_day, end_day must be strings with day values (from Monday to Sunday in proper case)
start_time and end_time must be of type datetime.time() with the values from time range given below.
Modify the values of vehicle columns according to the following time ranges:

Weekdays (Monday - Friday):

1. From 00:00:00 to 10:00:00: Apply a discount factor of 0.8
2. From 10:00:00 to 18:00:00: Apply a discount factor of 1.2
3. From 18:00:00 to 23:59:59: Apply a discount factor of 0.8

Weekends (Saturday and Sunday):

1. Apply a constant discount factor of 0.7 for all times.


For each unique (id_start, id_end) pair, cover a full 24-hour period (from 12:00:00 AM to 11:59:59 PM) and span all 7 days of the week (from Monday to Sunday).
"""

import pandas as pd
from datetime import time, timedelta

def calculate_time_based_toll_rates(df) -> pd.DataFrame:
    """
    Calculate time-based toll rates for different time intervals within a day.

    Args:
        df (pandas.DataFrame)

    Returns:
        pandas.DataFrame: DataFrame with additional columns for time-based toll rates.
    """
    # Define time intervals and discount factors for weekdays
    weekday_intervals = [
        (time(0, 0, 0), time(10, 0, 0), 0.8),   # 00:00:00 - 10:00:00
        (time(10, 0, 0), time(18, 0, 0), 1.2),  # 10:00:00 - 18:00:00
        (time(18, 0, 0), time(23, 59, 59), 0.8) # 18:00:00 - 23:59:59
    ]
    weekend_factor = 0.7  # Constant discount factor for weekends

    # Days of the week
    weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    weekends = ['Saturday', 'Sunday']

    # Create a list to store the results
    expanded_data = []

    # Loop through each row in the DataFrame
    for _, row in df.iterrows():
        id_start, id_end, distance, moto, car, rv, bus, truck = row[['id_start', 'id_end', 'distance', 'moto', 'car', 'rv', 'bus', 'truck']]

        # Loop over all 7 days of the week
        for day in weekdays + weekends:
            # Determine if it is a weekday or weekend
            is_weekend = day in weekends

            # Calculate toll rates for each time interval
            if is_weekend:
                # Single time interval for weekends
                start_time = time(0, 0, 0)
                end_time = time(23, 59, 59)

                # Calculate discounted toll rates
                adjusted_moto = moto * weekend_factor
                adjusted_car = car * weekend_factor
                adjusted_rv = rv * weekend_factor
                adjusted_bus = bus * weekend_factor
                adjusted_truck = truck * weekend_factor

                # Append to expanded data
                expanded_data.append({
                    'id_start': id_start,
                    'id_end': id_end,
                    'distance': distance,
                    'moto': adjusted_moto,
                    'car': adjusted_car,
                    'rv': adjusted_rv,
                    'bus': adjusted_bus,
                    'truck': adjusted_truck,
                    'start_day': day,
                    'start_time': start_time,
                    'end_day': day,
                    'end_time': end_time
                })
            else:
                # Multiple time intervals for weekdays
                for start_time, end_time, factor in weekday_intervals:
                    # Calculate discounted toll rates
                    adjusted_moto = moto * factor
                    adjusted_car = car * factor
                    adjusted_rv = rv * factor
                    adjusted_bus = bus * factor
                    adjusted_truck = truck * factor

                    # Append to expanded data
                    expanded_data.append({
                        'id_start': id_start,
                        'id_end': id_end,
                        'distance': distance,
                        'moto': adjusted_moto,
                        'car': adjusted_car,
                        'rv': adjusted_rv,
                        'bus': adjusted_bus,
                        'truck': adjusted_truck,
                        'start_day': day,
                        'start_time': start_time,
                        'end_day': day,
                        'end_time': end_time
                    })

    # Convert the list of dictionaries to a DataFrame
    expanded_df = pd.DataFrame(expanded_data)

    return expanded_df

calculate_time_based_toll_rates(mapup2)